["{\"transientOutputs\":false,\"transientCellMetadata\":{\"state\":true,\"name\":false,\"languageMetadata\":false,\"stableId\":false,\"options\":false},\"transientDocumentMetadata\":{\"app\":false,\"header\":false,\"version\":false,\"cells\":true,\"violations\":false,\"valid\":false},\"cellContentMetadata\":{}}","{\"cells\":[],\"metadata\":{\"app\":{\"options\":{}},\"header\":{\"value\":\"\\\"\\\"\\\"\\nMain MADTOR simulation engine\\nOrchestrates the complete simulation loop\\n\\\"\\\"\\\"\\n\\nimport random\\nimport math\\nimport logging\\nfrom typing import Dict, List, Tuple, Optional\\nimport json\\nfrom datetime import datetime\\nfrom pathlib import Path\\n\\nimport madtor.config as config\\nfrom madtor.agents import Trafficker, Packager, Retailer, Agent, Network\\nfrom madtor.activities import DrugTraffickingActivities\\nfrom madtor.law_enforcement import LawEnforcement\\nfrom madtor.statistics import NetworkStatistics, DataCollector\\nfrom madtor.utils import load_nodes_file, load_links_file, infer_agent_type\\n\\n\\nclass MADTORSimulation:\\n    \\\"\\\"\\\"Main simulation controller\\\"\\\"\\\"\\n\\n    def __init__(\\n        self,\\n        arrest_scenario: int = 0,\\n        disruption_mode: str = \\\"scenario1\\\",\\n        efficiency_vs_security: float = 0.5,\\n        seed: int = None,\\n    ):\\n        \\\"\\\"\\\"\\n        Initialize simulation\\n\\n        Args:\\n            arrest_scenario: Percentage of members to arrest in major disruption\\n            disruption_mode: \\\"scenario1\\\", \\\"scenario2\\\", or \\\"scenario3\\\"\\n            efficiency_vs_security: Trade-off parameter (0.0 to 1.0)\\n            seed: Random seed for reproducibility\\n        \\\"\\\"\\\"\\n        self.seed = seed if seed is not None else random.randint(0, 2**32 - 1)\\n        random.seed(self.seed)\\n\\n        self.arrest_scenario = arrest_scenario\\n        self.disruption_mode = disruption_mode\\n        self.efficiency_vs_security = efficiency_vs_security\\n\\n        self.tick = 0\\n        self.running = True\\n\\n        # Initialize data structures\\n        self.network = None\\n        self.global_state = self._initialize_global_state()\\n        self.activities = None\\n        self.law_enforcement = None\\n        self.statistics = None\\n        self.data_collector = DataCollector()\\n\\n        # Setup\\n        self._setup()\\n\\n    def _initialize_global_state(self) -> Dict:\\n        \\\"\\\"\\\"Initialize global state variables\\\"\\\"\\\"\\n        return {\\n            # Temporal\\n            \\\"tick\\\": 0,\\n            \\\"ticks_traffickers\\\": 0,\\n            \\\"ticks_packagers\\\": 0,\\n            \\\"ticks_retailers\\\": 0,\\n            \\\"current_year\\\": 1,\\n            # Agent counts\\n            \\\"n_active_traffickers\\\": config.INITIAL_TRAFFICKERS,\\n            \\\"n_active_packagers\\\": config.INITIAL_PACKAGERS,\\n            \\\"n_active_retailers\\\": config.INITIAL_RETAILERS,\\n            # Drug trafficking\\n            \\\"drug_package_of_traffickers\\\": 0,\\n            \\\"drug_package_of_packagers\\\": 0,\\n            \\\"drug_package_of_retailers\\\": config.DRUG_PACKAGE_RETAILERS,\\n            \\\"gram_per_dose\\\": config.GRAM_PER_DOSE,\\n            \\\"unit_dose\\\": config.UNIT_DOSE_2008,\\n            \\\"unit_dose_min\\\": config.UNIT_DOSE_MIN_2008,\\n            \\\"unit_dose_max\\\": config.UNIT_DOSE_MAX_2008,\\n            \\\"unit_dose_now\\\": config.UNIT_DOSE_2008,\\n            # Stock tracking\\n            \\\"stock_drug\\\": 0,\\n            \\\"stock_drug_traffickers\\\": 0,\\n            \\\"stock_drug_packagers\\\": 0,\\n            \\\"stock_drug_retailers\\\": 0,\\n            \\\"target_stock_drug\\\": 0,\\n            # Prices\\n            \\\"wholesale_price\\\": config.WHOLESALE_PRICE_2008,\\n            \\\"wholesale_price_now\\\": config.WHOLESALE_PRICE_2008,\\n            \\\"retail_price\\\": config.RETAIL_PRICE_2008,\\n            \\\"price_per_dose\\\": config.PRICE_PER_DOSE,\\n            # Financial\\n            \\\"cash_box\\\": 0,\\n            \\\"revenues\\\": 0,\\n            \\\"expenses\\\": 0,\\n            \\\"profit_of_traffickers\\\": 0,\\n            \\\"profit_of_packagers\\\": 0,\\n            \\\"profit_of_retailers\\\": 0,\\n            \\\"weekly_profit\\\": config.WEEKLY_PROFIT_2008,\\n            \\\"weekly_profit_now\\\": 0,\\n            \\\"cost_per_day\\\": config.COST_PER_DAY_2008,\\n            # Profit tracking\\n            \\\"profit_of_traffickers_min\\\": config.PROFIT_RANGES[\\n                self.efficiency_vs_security\\n            ][\\\"traffickers_min\\\"],\\n            \\\"profit_of_traffickers_max\\\": config.PROFIT_RANGES[\\n                self.efficiency_vs_security\\n            ][\\\"traffickers_max\\\"],\\n            \\\"profit_of_packagers_min\\\": config.PROFIT_RANGES[\\n                self.efficiency_vs_security\\n            ][\\\"packagers_min\\\"],\\n            \\\"profit_of_packagers_max\\\": config.PROFIT_RANGES[\\n                self.efficiency_vs_security\\n            ][\\\"packagers_max\\\"],\\n            \\\"profit_of_retailers_max\\\": config.PROFIT_OF_RETAILERS_MAX,\\n            # Profit shares\\n            \\\"traffickers_share_of_profits\\\": config.TRAFFICKERS_SHARE_OF_PROFITS,\\n            \\\"retailers_share_of_profits\\\": config.RETAILERS_SHARE_OF_PROFITS,\\n            # Activity tracking\\n            \\\"n_acquisition\\\": 0,\\n            \\\"n_exhaust_traffickers\\\": 0,\\n            \\\"n_exhaust_packagers\\\": 0,\\n            \\\"n_exhaust_retailers\\\": 0,\\n            \\\"n_exhaust_retailers_90\\\": 0,\\n            # Family wage/support tracking\\n            \\\"arrested_retailers_family\\\": 0,\\n            \\\"dead_members_family\\\": 0,\\n            \\\"fm_traffickers_wage\\\": 0,\\n            \\\"fm_packagers_wage\\\": 0,\\n            \\\"fm_retailers_wage\\\": 0,\\n            \\\"arrested_retailers_family_wages\\\": 0,\\n            \\\"dead_members_family_wages\\\": 0,\\n            \\\"arrested_homicide_family_wages\\\": config.ARRESTED_HOMICIDE_FAMILY_WAGES\\n            if hasattr(config, \\\"ARRESTED_HOMICIDE_FAMILY_WAGES\\\")\\n            else 2 * 3500,\\n            \\\"n_weekly_profit_min\\\": 0,\\n            \\\"n_weekly_profit_max\\\": 0,\\n            \\\"n_weekly_profit_neg\\\": 0,\\n            # Law enforcement\\n            \\\"n_disruptions_obs\\\": 1,\\n            \\\"target_of_disruption\\\": \\\"turtles\\\",\\n            \\\"arrested_mode\\\": \\\"arrested%\\\",\\n            \\\"arrested%\\\": self.arrest_scenario,\\n            \\\"arrested#\\\": 0,\\n            \\\"target_of_disruption\\\": \\\"turtles\\\",\\n            \\\"disruption_mode\\\": self.disruption_mode,\\n            \\\"efficiency_vs_security\\\": self.efficiency_vs_security,\\n            \\\"ticks_disruption\\\": None,\\n            \\\"stop_acquire_days\\\": config.STOP_ACQUIRE_DAYS_DEFAULT,\\n            \\\"stop_acquiring_until\\\": None,\\n            # Arrest tracking\\n            \\\"n_arrested_traffickers_minor\\\": 0,\\n            \\\"n_arrested_packagers_minor\\\": 0,\\n            \\\"n_arrested_retailers_minor\\\": 0,\\n            \\\"n_arrested_traffickers_major\\\": 0,\\n            \\\"n_arrested_packagers_major\\\": 0,\\n            \\\"n_arrested_retailers_major\\\": 0,\\n            # Calibration values\\n            \\\"traffickers_2008\\\": config.TRAFFICKERS_2008,\\n            \\\"traffickers_2010\\\": config.TRAFFICKERS_2010,\\n            \\\"packagers_2008\\\": config.PACKAGERS_2008,\\n            \\\"packagers_2010\\\": config.PACKAGERS_2010,\\n            \\\"retailers_2008\\\": config.RETAILERS_2008,\\n            \\\"retailers_2010\\\": config.RETAILERS_2010,\\n            # Min/max tracking\\n            \\\"minw\\\": float(\\\"inf\\\"),\\n            \\\"maxw\\\": float(\\\"-inf\\\"),\\n            \\\"minacq_ind\\\": float(\\\"inf\\\"),\\n            \\\"maxacq_ind\\\": float(\\\"-inf\\\"),\\n            \\\"mincash\\\": float(\\\"inf\\\"),\\n            \\\"maxcash\\\": float(\\\"-inf\\\"),\\n        }\\n\\n    def _setup(self):\\n        \\\"\\\"\\\"Initialize simulation\\\"\\\"\\\"\\n        # Try to load from real data files\\n        nodes_file = Path(\\\"madtor/data/T2_Nodes.prn\\\")\\n        links_file = Path(\\\"madtor/data/T2_Links.prn\\\")\\n\\n        if nodes_file.exists() and links_file.exists():\\n            self._setup_from_real_data(nodes_file, links_file)\\n        else:\\n            self._setup_with_random_initialization()\\n\\n    def _setup_from_real_data(self, nodes_file: Path, links_file: Path):\\n        \\\"\\\"\\\"Initialize simulation from real data files\\\"\\\"\\\"\\n        # Load data\\n        nodes_data = load_nodes_file(str(nodes_file))\\n        links_data = load_links_file(str(links_file))\\n\\n        # Create agents based on node data\\n        agents = []\\n        agent_map = {}  # Map node_id -> Agent\\n\\n        for node_id, roles in nodes_data.items():\\n            agent_type = infer_agent_type(node_id, {node_id: roles})\\n\\n            if agent_type == \\\"trafficker\\\":\\n                agent = Trafficker(f\\\"{node_id}\\\")\\n            elif agent_type == \\\"packager\\\":\\n                agent = Packager(f\\\"{node_id}\\\")\\n            else:\\n                agent = Retailer(f\\\"{node_id}\\\")\\n\\n            agent.node_id = node_id\\n            agent.role_category = roles.get(\\\"role_category1\\\", \\\"n/a\\\")\\n            agents.append(agent)\\n            agent_map[node_id] = agent\\n\\n        # Create network\\n        self.network = Network(agents)\\n\\n        # Add links based on link data\\n        for link in links_data:\\n            source_id = link[\\\"source\\\"]\\n            target_id = link[\\\"target\\\"]\\n            familiarity = link[\\\"familiarity\\\"]\\n\\n            if source_id in agent_map and target_id in agent_map:\\n                self.network.add_link(\\n                    agent_map[source_id].agent_id,\\n                    agent_map[target_id].agent_id,\\n                    f\\\"{link['role1']}-{link['role2']}\\\",\\n                    familiarity,\\n                )\\n\\n        # Initialize activities and law enforcement\\n        self.activities = DrugTraffickingActivities(self.network, self.global_state)\\n        self.law_enforcement = LawEnforcement(self.network, self.global_state)\\n        self.statistics = NetworkStatistics(self.network)\\n\\n        # Update agent counts in global state\\n        traffickers = self.network.get_active_agents_by_type(\\\"trafficker\\\")\\n        packagers = self.network.get_active_agents_by_type(\\\"packager\\\")\\n        retailers = self.network.get_active_agents_by_type(\\\"retailer\\\")\\n\\n        self.global_state[\\\"n_active_traffickers\\\"] = len(traffickers)\\n        self.global_state[\\\"n_active_packagers\\\"] = len(packagers)\\n        self.global_state[\\\"n_active_retailers\\\"] = len(retailers)\\n\\n        # Calculate initial parameters\\n        self._calculate_initial_parameters()\\n\\n        # Initialize drug stocks\\n        self._initialize_drug_stocks()\\n\\n    def _setup_with_random_initialization(self):\\n        \\\"\\\"\\\"Initialize simulation with random agents (fallback)\\\"\\\"\\\"\\n        # Create agents\\n        agents = []\\n\\n        # Create traffickers\\n        for i in range(config.INITIAL_TRAFFICKERS):\\n            agents.append(Trafficker(f\\\"trafficker_{i}\\\"))\\n\\n        # Create packagers\\n        for i in range(config.INITIAL_PACKAGERS):\\n            agents.append(Packager(f\\\"packager_{i}\\\"))\\n\\n        # Create retailers\\n        for i in range(config.INITIAL_RETAILERS):\\n            agents.append(Retailer(f\\\"retailer_{i}\\\"))\\n\\n        # Create network\\n        self.network = Network(agents)\\n\\n        # Initialize activities and law enforcement\\n        self.activities = DrugTraffickingActivities(self.network, self.global_state)\\n        self.law_enforcement = LawEnforcement(self.network, self.global_state)\\n        self.statistics = NetworkStatistics(self.network)\\n\\n        # Calculate initial parameters\\n        self._calculate_initial_parameters()\\n\\n        # Initialize drug stocks\\n        self._initialize_drug_stocks()\\n\\n        # Create initial network links (random)\\n        self._create_initial_links()\\n\\n    def _calculate_initial_parameters(self):\\n        \\\"\\\"\\\"Calculate drug package sizes and financial parameters\\\"\\\"\\\"\\n        efficiency_factor = self.efficiency_vs_security / 3\\n\\n        # Drug packages\\n        unit_dose_range = (\\n            self.global_state[\\\"unit_dose_max\\\"] - self.global_state[\\\"unit_dose_min\\\"]\\n        )\\n        avg_dose = (\\n            self.global_state[\\\"unit_dose_min\\\"] + unit_dose_range * efficiency_factor\\n        )\\n\\n        gram_per_dose = self.global_state[\\\"gram_per_dose\\\"]\\n\\n        # Package for traffickers (monthly)\\n        n_traffickers = max(1, self.global_state[\\\"n_active_traffickers\\\"])\\n        self.global_state[\\\"drug_package_of_traffickers\\\"] = (\\n            avg_dose * gram_per_dose / n_traffickers * 30\\n        )\\n\\n        # Package for packagers (daily)\\n        n_packagers = max(1, self.global_state[\\\"n_active_packagers\\\"])\\n        self.global_state[\\\"drug_package_of_packagers\\\"] = (\\n            avg_dose * gram_per_dose / n_packagers\\n        )\\n\\n        # Financial parameters\\n        supply_costs = (\\n            self.global_state[\\\"wholesale_price\\\"] / self.global_state[\\\"retail_price\\\"]\\n        )\\n        cost_per_day = self.global_state[\\\"cost_per_day\\\"]\\n\\n        # Trafficker profits\\n        n_traffickers = max(1, self.global_state[\\\"n_active_traffickers\\\"])\\n        profit_t = (\\n            (cost_per_day - cost_per_day * supply_costs)\\n            * config.TRAFFICKERS_SHARE_OF_PROFITS\\n            / n_traffickers\\n        )\\n        profit_t = max(\\n            self.global_state[\\\"profit_of_traffickers_min\\\"],\\n            min(self.global_state[\\\"profit_of_traffickers_max\\\"], profit_t),\\n        )\\n        self.global_state[\\\"profit_of_traffickers\\\"] = profit_t\\n\\n        # Packager profits\\n        n_packagers = max(1, self.global_state[\\\"n_active_packagers\\\"])\\n        profit_p = (\\n            (cost_per_day - cost_per_day * supply_costs)\\n            * (1 - config.TRAFFICKERS_SHARE_OF_PROFITS)\\n            / n_packagers\\n        )\\n        profit_p = max(\\n            self.global_state[\\\"profit_of_packagers_min\\\"],\\n            min(self.global_state[\\\"profit_of_packagers_max\\\"], profit_p),\\n        )\\n        self.global_state[\\\"profit_of_packagers\\\"] = profit_p\\n\\n        # Retailer profits\\n        n_retailers = max(1, self.global_state[\\\"n_active_retailers\\\"])\\n        profit_r = (\\n            self.global_state[\\\"unit_dose\\\"]\\n            * config.PRICE_PER_DOSE\\n            * config.RETAILERS_SHARE_OF_PROFITS\\n            / n_retailers\\n        )\\n        profit_r = min(self.global_state[\\\"profit_of_retailers_max\\\"], profit_r)\\n        self.global_state[\\\"profit_of_retailers\\\"] = profit_r\\n\\n        # Target stock\\n        start_up_months = 2\\n        self.global_state[\\\"target_stock_drug\\\"] = (\\n            self.global_state[\\\"unit_dose\\\"] * gram_per_dose * start_up_months * 30\\n        )\\n\\n        # Cash box\\n        self.global_state[\\\"cash_box\\\"] = config.START_UP_MONEY\\n\\n    def _initialize_drug_stocks(self):\\n        \\\"\\\"\\\"Distribute initial drug stocks\\\"\\\"\\\"\\n        target_stock = self.global_state[\\\"target_stock_drug\\\"]\\n\\n        packagers = self.network.get_active_agents_by_type(\\\"packager\\\")\\n        retailers = self.network.get_active_agents_by_type(\\\"retailer\\\")\\n\\n        if packagers:\\n            packager_stock = (\\n                target_stock\\n                - 2\\n                * self.global_state[\\\"unit_dose\\\"]\\n                * self.global_state[\\\"gram_per_dose\\\"]\\n            )\\n            per_packager = packager_stock / len(packagers)\\n            for packager in packagers:\\n                packager.drug = per_packager\\n            self.global_state[\\\"stock_drug_packagers\\\"] = packager_stock\\n\\n        if retailers:\\n            retailer_stock = target_stock - self.global_state[\\\"stock_drug_packagers\\\"]\\n            per_retailer = retailer_stock / len(retailers)\\n            for retailer in retailers:\\n                retailer.drug = per_retailer\\n            self.global_state[\\\"stock_drug_retailers\\\"] = retailer_stock\\n\\n        self.global_state[\\\"stock_drug\\\"] = target_stock\\n\\n    def _create_initial_links(self):\\n        \\\"\\\"\\\"Create initial network links\\\"\\\"\\\"\\n        # In real model, this would load from T2_Links.prn file\\n        # For now, create random links between traffickers and packagers, packagers and retailers\\n\\n        traffickers = self.network.get_active_agents_by_type(\\\"trafficker\\\")\\n        packagers = self.network.get_active_agents_by_type(\\\"packager\\\")\\n        retailers = self.network.get_active_agents_by_type(\\\"retailer\\\")\\n\\n        # Create some trafficker-packager links\\n        for packager in packagers:\\n            if traffickers:\\n                trafficker = random.choice(traffickers)\\n                self.network.add_link(\\n                    trafficker.agent_id, packager.agent_id, \\\"trafficker-packager\\\"\\n                )\\n\\n        # Create some packager-retailer links\\n        for retailer in retailers:\\n            if packagers:\\n                packager = random.choice(packagers)\\n                self.network.add_link(\\n                    packager.agent_id, retailer.agent_id, \\\"packager-retailer\\\"\\n                )\\n\\n    def step(self):\\n        \\\"\\\"\\\"Execute one simulation tick (one day)\\\"\\\"\\\"\\n        self.tick += 1\\n        self.global_state[\\\"tick\\\"] = self.tick\\n        self.global_state[\\\"ticks_traffickers\\\"] = (\\n            self.global_state.get(\\\"ticks_traffickers\\\", 0) + 1\\n        )\\n        self.global_state[\\\"ticks_packagers\\\"] = (\\n            self.global_state.get(\\\"ticks_packagers\\\", 0) + 1\\n        )\\n        self.global_state[\\\"ticks_retailers\\\"] = (\\n            self.global_state.get(\\\"ticks_retailers\\\", 0) + 1\\n        )\\n\\n        # Reset daily aggregates\\n        self.global_state[\\\"revenues\\\"] = 0\\n        self.global_state[\\\"expenses\\\"] = 0\\n        self.global_state[\\\"weekly_profit_now\\\"] = 0\\n\\n        # Drug trafficking activities\\n        self.activities.acquire_drug(self.tick)\\n        self.activities.package_drug(self.tick)\\n        self.activities.sell_drug(self.tick)\\n\\n        # Law enforcement\\n        self.law_enforcement.perform_minor_arrests(self.tick)\\n\\n        # Major disruption at end of year 2\\n        if self.tick == config.MAJOR_DISRUPTION_TICK:\\n            self.law_enforcement.perform_major_arrest(self.tick, self.arrest_scenario)\\n            self._update_parameters()\\n\\n        # Check acquisition disruption\\n        if not self.law_enforcement.apply_acquisition_disruption(self.tick):\\n            pass  # Already handled in acquire_drug\\n\\n        # Weekly expenses (every 7 days)\\n        if self.tick % 7 == 0:\\n            self._account_for_expenses()\\n\\n        # Update parameters (every 30 days)\\n        if self.tick % 30 == 0 and self.tick > 0:\\n            self._update_parameters()\\n\\n        # Collect statistics\\n        network_stats = self.statistics.compute_all_statistics()\\n        self._update_agent_counts()\\n        self.data_collector.record(self.tick, self.global_state, network_stats)\\n\\n        # Check organization viability\\n        if not self.law_enforcement.check_organization_viability():\\n            self.running = False\\n            return False\\n\\n        # Check year-end status\\n        if self.tick % config.TICKS_PER_YEAR == 0:\\n            self._check_yearly_status()\\n\\n        return True\\n\\n    def _account_for_expenses(self):\\n        \\\"\\\"\\\"Account for weekly wages, family support, and bounded profit.\\\"\\\"\\\"\\n        traffickers = self.network.get_active_agents_by_type(\\\"trafficker\\\")\\n        packagers = self.network.get_active_agents_by_type(\\\"packager\\\")\\n        retailers = self.network.get_active_agents_by_type(\\\"retailer\\\")\\n\\n        weekly_profit_now = self.global_state.get(\\\"weekly_profit_now\\\", 0)\\n\\n        def apply_expense(amount: float):\\n            self.global_state[\\\"cash_box\\\"] -= amount\\n            self.global_state[\\\"expenses\\\"] += amount\\n\\n        # Weekly operational costs\\n        cost_per_day = self.global_state[\\\"cost_per_day\\\"]\\n        weekly_cost = cost_per_day * 7\\n        apply_expense(weekly_cost)\\n\\n        # Wages for traffickers and packagers\\n        wage_traff_pack = (\\n            (self.global_state[\\\"profit_of_traffickers\\\"] * len(traffickers))\\n            + (self.global_state[\\\"profit_of_packagers\\\"] * len(packagers))\\n        ) * 7\\n        apply_expense(wage_traff_pack)\\n\\n        # Support for families of arrested retailers\\n        arrested_retailers_family = self.global_state.get(\\n            \\\"arrested_retailers_family\\\", 0\\n        )\\n        expected_arrested_retailers = len(retailers) * 0.56\\n        base_retailer_support = max(\\n            expected_arrested_retailers, arrested_retailers_family\\n        )\\n        retailer_family_wage = (\\n            base_retailer_support * config.ARRESTED_RETAILERS_WEEKLY_WAGE\\n            + self.global_state.get(\\\"fm_retailers_wage\\\", 0)\\n            * config.ARRESTED_RETAILERS_WEEKLY_WAGE\\n        )\\n        self.global_state[\\\"arrested_retailers_family_wages\\\"] = retailer_family_wage\\n        apply_expense(retailer_family_wage)\\n\\n        # Support for families of dead members (all roles)\\n        dead_members_family = self.global_state.get(\\\"dead_members_family\\\", 0)\\n        expected_dead_members = (\\n            len(traffickers) + len(packagers) + len(retailers)\\n        ) * 0.10\\n        base_dead_support = max(expected_dead_members, dead_members_family)\\n        dead_members_wage = (\\n            base_dead_support * config.ARRESTED_OTHER_WEEKLY_WAGE\\n            + (\\n                self.global_state.get(\\\"fm_traffickers_wage\\\", 0)\\n                + self.global_state.get(\\\"fm_packagers_wage\\\", 0)\\n            )\\n            * config.ARRESTED_OTHER_WEEKLY_WAGE\\n        )\\n        self.global_state[\\\"dead_members_family_wages\\\"] = dead_members_wage\\n        apply_expense(dead_members_wage)\\n\\n        # Support for homicide-related families\\n        homicide_family_wages = self.global_state.get(\\n            \\\"arrested_homicide_family_wages\\\", 0\\n        )\\n        apply_expense(homicide_family_wages)\\n\\n        # Bound profit with random noise\\n        weekly_profit = self.global_state[\\\"weekly_profit\\\"]\\n        weekly_profit_max = weekly_profit\\n        weekly_profit_min = weekly_profit * 0.9\\n\\n        # Add symmetric random fluctuation (~Uniform[-0.1, 0.1])\\n        fluctuation = random.uniform(-0.1 * weekly_profit_now, 0.1 * weekly_profit_now)\\n        weekly_profit_now += fluctuation\\n\\n        if weekly_profit_now > weekly_profit_max:\\n            self.global_state[\\\"n_weekly_profit_max\\\"] += 1\\n            weekly_profit_now = weekly_profit_max\\n        elif weekly_profit_now < weekly_profit_min:\\n            self.global_state[\\\"n_weekly_profit_min\\\"] += 1\\n            weekly_profit_now = weekly_profit_min\\n\\n        if weekly_profit_now < 0:\\n            self.global_state[\\\"n_weekly_profit_neg\\\"] += 1\\n\\n        # Reset accumulator; cash_box already reflects daily revenues/expenses adjustments\\n        self.global_state[\\\"weekly_profit_now\\\"] = 0\\n\\n    def _is_recruitment_paused(self, tick: int) -> bool:\\n        \\\"\\\"\\\"Mirror NetLogo stop logic during disruption for recruitment/updates.\\\"\\\"\\\"\\n        ticks_disruption = self.global_state.get(\\\"ticks_disruption\\\")\\n        stop_acquire_days = self.global_state.get(\\\"stop_acquire_days\\\", 0)\\n        arrest_mode = self.global_state.get(\\\"arrested_mode\\\", \\\"arrested%\\\")\\n\\n        if ticks_disruption is None:\\n            return False\\n\\n        if tick > ticks_disruption and tick <= ticks_disruption + stop_acquire_days:\\n            if arrest_mode == \\\"arrested%\\\":\\n                arrested_pct = self.global_state.get(\\\"arrested%\\\", 0)\\n                if arrested_pct != 0:\\n                    if tick <= ticks_disruption + stop_acquire_days / 2:\\n                        rd1 = random.randint(0, 99)\\n                        if rd1 <= arrested_pct:\\n                            return True\\n                        rd = random.uniform(0, 1.1)\\n                        if rd <= (1 - self.efficiency_vs_security):\\n                            return True\\n                    else:\\n                        rd = random.uniform(0, 1.1)\\n                        if rd <= (1 - self.efficiency_vs_security):\\n                            return True\\n            else:\\n                arrested_num = self.global_state.get(\\\"arrested#\\\", 0)\\n                if arrested_num != 0:\\n                    total_agents = (\\n                        len(self.network.get_active_agents()) if self.network else 0\\n                    )\\n                    if tick <= ticks_disruption + stop_acquire_days / 2:\\n                        rd1 = random.randint(0, max(total_agents, 1))\\n                        if rd1 <= arrested_num:\\n                            return True\\n                        rd = random.uniform(0, 1.1)\\n                        if rd <= (1 - self.efficiency_vs_security):\\n                            return True\\n                    else:\\n                        rd = random.uniform(0, 1.1)\\n                        if rd <= (1 - self.efficiency_vs_security):\\n                            return True\\n\\n        return False\\n\\n    def _update_parameters(self):\\n        \\\"\\\"\\\"Update parameters and recruitment following NetLogo update-parameters.\\\"\\\"\\\"\\n        tick = self.tick\\n        tick_max = 2 * config.TICKS_PER_YEAR\\n\\n        # Scenario 3 stop-acquire schedule adjustments\\n        if self.disruption_mode == \\\"scenario3\\\":\\n            scenario3_schedule = {\\n                450: 90,\\n                630: 90,\\n                810: 60,\\n                990: 60,\\n                1170: 30,\\n                1350: 30,\\n                1530: 0,\\n            }\\n            ticks_disruption = self.global_state.get(\\\"ticks_disruption\\\")\\n            if ticks_disruption in scenario3_schedule:\\n                self.global_state[\\\"stop_acquire_days\\\"] = scenario3_schedule[\\n                    ticks_disruption\\n                ]\\n\\n        # During disruption pauses, skip recruitment/updates according to NetLogo stop checks\\n        if self._is_recruitment_paused(tick):\\n            return\\n\\n        # Helpers\\n        def log_growth(base_val: float, target_val: float, ticks_counter: int) -> float:\\n            y_range = target_val - base_val\\n            if y_range <= 0:\\n                return base_val\\n            return base_val + (\\n                math.log(1 + ticks_counter * y_range / tick_max, y_range + 1) * y_range\\n            )\\n\\n        # Current counts\\n        traffickers = self.network.get_active_agents_by_type(\\\"trafficker\\\")\\n        packagers = self.network.get_active_agents_by_type(\\\"packager\\\")\\n        retailers = self.network.get_active_agents_by_type(\\\"retailer\\\")\\n\\n        # Supply costs based on current prices (before price updates later in this step)\\n        supply_costs = (\\n            self.global_state[\\\"wholesale_price\\\"] / self.global_state[\\\"retail_price\\\"]\\n        )\\n\\n        # Trafficker recruitment\\n        y_traffickers = round(\\n            log_growth(\\n                config.TRAFFICKERS_2008,\\n                config.TRAFFICKERS_2010,\\n                self.global_state[\\\"ticks_traffickers\\\"],\\n            )\\n        )\\n        if len(traffickers) == 0 or y_traffickers > len(traffickers):\\n            profit_of_traffickers = (\\n                (\\n                    self.global_state[\\\"cost_per_day\\\"]\\n                    - self.global_state[\\\"cost_per_day\\\"] * supply_costs\\n                )\\n                * self.global_state[\\\"traffickers_share_of_profits\\\"]\\n                / (len(traffickers) + 1)\\n            )\\n            rd = random.uniform(0, 1.1)\\n            if profit_of_traffickers > self.global_state[\\n                \\\"profit_of_traffickers_min\\\"\\n            ] and rd > (1 - self.efficiency_vs_security):\\n                new_trafficker = Trafficker(role_category=f\\\"new-traffickers-{tick}\\\")\\n                self.network.add_agent(new_trafficker)\\n                if packagers:\\n                    partner = random.choice(packagers)\\n                    self.network.add_link(\\n                        new_trafficker.agent_id, partner.agent_id, \\\"trafficker-packager\\\"\\n                    )\\n                else:\\n                    self.running = False\\n                    return\\n                traffickers.append(new_trafficker)\\n                self.global_state[\\\"n_active_traffickers\\\"] = len(traffickers)\\n\\n        # Packager recruitment\\n        y_packagers = round(\\n            log_growth(\\n                config.PACKAGERS_2008,\\n                config.PACKAGERS_2010,\\n                self.global_state[\\\"ticks_packagers\\\"],\\n            )\\n        )\\n        if len(packagers) == 0 or y_packagers > len(packagers):\\n            profit_of_packagers = (\\n                (\\n                    self.global_state[\\\"cost_per_day\\\"]\\n                    - self.global_state[\\\"cost_per_day\\\"] * supply_costs\\n                )\\n                * (1 - self.global_state[\\\"traffickers_share_of_profits\\\"])\\n                / (len(packagers) + 1)\\n            )\\n            rd = random.uniform(0, 1.5)\\n            if profit_of_packagers > self.global_state[\\n                \\\"profit_of_packagers_min\\\"\\n            ] and rd > (1 - self.efficiency_vs_security):\\n                new_packager = Packager(role_category=f\\\"new-packagers-{tick}\\\")\\n                self.network.add_agent(new_packager)\\n                if random.randint(0, 1) == 1:\\n                    if traffickers:\\n                        partner = random.choice(traffickers)\\n                        self.network.add_link(\\n                            partner.agent_id,\\n                            new_packager.agent_id,\\n                            \\\"trafficker-packager\\\",\\n                        )\\n                    else:\\n                        self.running = False\\n                        return\\n                else:\\n                    if retailers:\\n                        partner = random.choice(retailers)\\n                        self.network.add_link(\\n                            new_packager.agent_id, partner.agent_id, \\\"packager-retailer\\\"\\n                        )\\n                    else:\\n                        self.running = False\\n                        return\\n                packagers.append(new_packager)\\n                self.global_state[\\\"n_active_packagers\\\"] = len(packagers)\\n\\n        # Retailer recruitment\\n        y_retailers = round(\\n            log_growth(\\n                config.RETAILERS_2008,\\n                config.RETAILERS_2010,\\n                self.global_state[\\\"ticks_retailers\\\"],\\n            )\\n        )\\n        rd = random.uniform(0, 2)\\n        if len(retailers) == 0 or (\\n            int(y_retailers) > len(retailers) and rd > (1 - self.efficiency_vs_security)\\n        ):\\n            new_retailer = Retailer(role_category=f\\\"new-retailers-{tick}\\\")\\n            self.network.add_agent(new_retailer)\\n            if packagers:\\n                partner = random.choice(packagers)\\n                self.network.add_link(\\n                    partner.agent_id, new_retailer.agent_id, \\\"packager-retailer\\\"\\n                )\\n            else:\\n                self.running = False\\n                return\\n            retailers.append(new_retailer)\\n            self.global_state[\\\"n_active_retailers\\\"] = len(retailers)\\n\\n        # Unit doses (logarithmic growth over two years)\\n        self.global_state[\\\"unit_dose\\\"] = round(\\n            log_growth(config.UNIT_DOSE_2008, config.UNIT_DOSE_2010, tick)\\n        )\\n        self.global_state[\\\"unit_dose_min\\\"] = round(\\n            log_growth(config.UNIT_DOSE_MIN_2008, config.UNIT_DOSE_MIN_2010, tick)\\n        )\\n        self.global_state[\\\"unit_dose_max\\\"] = round(\\n            log_growth(config.UNIT_DOSE_MAX_2008, config.UNIT_DOSE_MAX_2010, tick)\\n        )\\n\\n        # Drug packages per role\\n        efficiency_vs_security_pack = self.efficiency_vs_security\\n        gram_per_dose = self.global_state[\\\"gram_per_dose\\\"]\\n\\n        if len(traffickers) > 0:\\n            self.global_state[\\\"drug_package_of_traffickers\\\"] = (\\n                (\\n                    self.global_state[\\\"unit_dose_min\\\"]\\n                    + (\\n                        self.global_state[\\\"unit_dose_max\\\"]\\n                        - self.global_state[\\\"unit_dose_min\\\"]\\n                    )\\n                    * efficiency_vs_security_pack\\n                )\\n                * gram_per_dose\\n                / len(traffickers)\\n                * 30\\n            )\\n        else:\\n            self.running = False\\n            return\\n\\n        if len(packagers) > 0:\\n            self.global_state[\\\"drug_package_of_packagers\\\"] = (\\n                (\\n                    self.global_state[\\\"unit_dose_min\\\"]\\n                    + (\\n                        self.global_state[\\\"unit_dose_max\\\"]\\n                        - self.global_state[\\\"unit_dose_min\\\"]\\n                    )\\n                    * efficiency_vs_security_pack\\n                )\\n                * gram_per_dose\\n                / len(packagers)\\n            )\\n        else:\\n            self.running = False\\n            return\\n\\n        if len(retailers) == 0:\\n            self.running = False\\n            return\\n\\n        # Target stock considering current unit doses\\n        start_up_months = config.START_UP_MONTHS\\n        self.global_state[\\\"target_stock_drug\\\"] = (\\n            self.global_state[\\\"unit_dose\\\"] * gram_per_dose * start_up_months * 30\\n        )\\n\\n        # Cost per day (logarithmic growth to 2010)\\n        self.global_state[\\\"cost_per_day\\\"] = round(\\n            log_growth(config.COST_PER_DAY_2008, config.COST_PER_DAY_2010, tick)\\n        )\\n\\n        # Profits (clamped)\\n        self.global_state[\\\"profit_of_traffickers\\\"] = max(\\n            self.global_state[\\\"profit_of_traffickers_min\\\"],\\n            min(\\n                self.global_state[\\\"profit_of_traffickers_max\\\"],\\n                (\\n                    self.global_state[\\\"cost_per_day\\\"]\\n                    - self.global_state[\\\"cost_per_day\\\"] * supply_costs\\n                )\\n                * self.global_state[\\\"traffickers_share_of_profits\\\"]\\n                / len(traffickers),\\n            ),\\n        )\\n\\n        self.global_state[\\\"profit_of_packagers\\\"] = max(\\n            self.global_state[\\\"profit_of_packagers_min\\\"],\\n            min(\\n                self.global_state[\\\"profit_of_packagers_max\\\"],\\n                (\\n                    self.global_state[\\\"cost_per_day\\\"]\\n                    - self.global_state[\\\"cost_per_day\\\"] * supply_costs\\n                )\\n                * (1 - self.global_state[\\\"traffickers_share_of_profits\\\"])\\n                / len(packagers),\\n            ),\\n        )\\n\\n        self.global_state[\\\"profit_of_retailers\\\"] = min(\\n            self.global_state[\\\"profit_of_retailers_max\\\"],\\n            self.global_state[\\\"unit_dose\\\"]\\n            * self.global_state[\\\"price_per_dose\\\"]\\n            * self.global_state[\\\"retailers_share_of_profits\\\"]\\n            / len(retailers),\\n        )\\n\\n        # Weekly profit (logarithmic growth to 2010)\\n        self.global_state[\\\"weekly_profit\\\"] = round(\\n            log_growth(config.WEEKLY_PROFIT_2008, config.WEEKLY_PROFIT_2010, tick)\\n        )\\n\\n        # Wholesale and retail prices (year-based updates)\\n        if tick > config.TICKS_PER_YEAR:\\n            self.global_state[\\\"wholesale_price\\\"] = config.WHOLESALE_PRICE_2009\\n            self.global_state[\\\"retail_price\\\"] = config.RETAIL_PRICE_2009\\n        if tick > 2 * config.TICKS_PER_YEAR:\\n            self.global_state[\\\"wholesale_price\\\"] = config.WHOLESALE_PRICE_2010\\n            self.global_state[\\\"retail_price\\\"] = config.RETAIL_PRICE_2010\\n\\n        # Update supply costs based on updated prices\\n        self.global_state[\\\"wholesale_price_now\\\"] = self.global_state[\\\"wholesale_price\\\"]\\n        self.global_state[\\\"retail_price_now\\\"] = self.global_state[\\\"retail_price\\\"]\\n        self.global_state[\\\"supply_costs\\\"] = (\\n            self.global_state[\\\"wholesale_price\\\"] / self.global_state[\\\"retail_price\\\"]\\n        )\\n\\n    def _update_agent_counts(self):\\n        \\\"\\\"\\\"Update active agent counts\\\"\\\"\\\"\\n        self.global_state[\\\"n_active_traffickers\\\"] = len(\\n            self.network.get_active_agents_by_type(\\\"trafficker\\\")\\n        )\\n        self.global_state[\\\"n_active_packagers\\\"] = len(\\n            self.network.get_active_agents_by_type(\\\"packager\\\")\\n        )\\n        self.global_state[\\\"n_active_retailers\\\"] = len(\\n            self.network.get_active_agents_by_type(\\\"retailer\\\")\\n        )\\n\\n    def _check_yearly_status(self):\\n        \\\"\\\"\\\"Check and log yearly status\\\"\\\"\\\"\\n        year = self.tick // config.TICKS_PER_YEAR\\n        if config.VERBOSE_OUTPUT:\\n            print(f\\\"\\\\nYear {year}:\\\")\\n            print(f\\\"  Cash box: €{self.global_state['cash_box']:.2f}\\\")\\n            print(\\n                f\\\"  Members: T={self.global_state['n_active_traffickers']}, \\\"\\n                f\\\"P={self.global_state['n_active_packagers']}, \\\"\\n                f\\\"R={self.global_state['n_active_retailers']}\\\"\\n            )\\n            print(f\\\"  Stock: {self.global_state['stock_drug']:.2f}g\\\")\\n\\n    def run(self, max_ticks: Optional[int] = None):\\n        \\\"\\\"\\\"Run simulation for specified number of ticks\\\"\\\"\\\"\\n        if max_ticks is None:\\n            max_ticks = config.TOTAL_TICKS\\n\\n        while self.tick < max_ticks and self.running:\\n            if not self.step():\\n                break\\n\\n            if self.tick % 100 == 0 and config.VERBOSE_OUTPUT:\\n                print(f\\\"Tick {self.tick}...\\\", end=\\\"\\\\r\\\")\\n\\n        return self.data_collector.get_data()\\n\\n    def get_results(self) -> Dict:\\n        \\\"\\\"\\\"Get simulation results\\\"\\\"\\\"\\n        return {\\n            \\\"arrest_scenario\\\": self.arrest_scenario,\\n            \\\"disruption_mode\\\": self.disruption_mode,\\n            \\\"efficiency_vs_security\\\": self.efficiency_vs_security,\\n            \\\"total_ticks\\\": self.tick,\\n            \\\"final_running\\\": self.running,\\n            \\\"final_cash_box\\\": self.global_state[\\\"cash_box\\\"],\\n            \\\"data\\\": self.data_collector.get_data(),\\n            \\\"seed\\\": self.seed,\\n        }\\n\\n\\ndef run_single_simulation(arrest_scenario: int = 0, num_runs: int = 1) -> Dict:\\n    \\\"\\\"\\\"\\n    Run single simulation scenario multiple times\\n\\n    Args:\\n        arrest_scenario: Percentage to arrest\\n        num_runs: Number of simulations to run\\n\\n    Returns:\\n        Aggregated results\\n    \\\"\\\"\\\"\\n    results = {\\n        \\\"arrest_scenario\\\": arrest_scenario,\\n        \\\"runs\\\": [],\\n        \\\"n_active_at_end\\\": 0,\\n    }\\n\\n    for run_num in range(num_runs):\\n        sim = MADTORSimulation(arrest_scenario=arrest_scenario)\\n        sim.run()\\n        results[\\\"runs\\\"].append(sim.get_results())\\n\\n        # Check if active at end\\n        if sim.running:\\n            results[\\\"n_active_at_end\\\"] += 1\\n\\n    return results\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    # Run example simulation\\n    print(\\\"Starting MADTOR simulation...\\\")\\n    sim = MADTORSimulation(arrest_scenario=10)\\n    sim.run()\\n\\n    print(f\\\"\\\\nSimulation completed at tick {sim.tick}\\\")\\n    print(f\\\"Running: {sim.running}\\\")\\n    print(f\\\"Cash box: €{sim.global_state['cash_box']:.2f}\\\")\\n    print(\\n        f\\\"Members: T={sim.global_state['n_active_traffickers']}, \\\"\\n        f\\\"P={sim.global_state['n_active_packagers']}, \\\"\\n        f\\\"R={sim.global_state['n_active_retailers']}\\\"\\n    )\"},\"version\":null,\"violations\":[{\"description\":\"Only able to extract header.\",\"lineno\":1,\"col_offset\":0},{\"description\":\"non-marimo Python content beyond header\",\"lineno\":7,\"col_offset\":0}],\"valid\":false}}"]